using System;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;
using System.Drawing;

using ConcurrentPriorityQueue;

using Ched.Core.Events;
using Ched.Core.Notes;
using Ched.Plugins;

using Microsoft.Web.WebView2.WinForms;

using SekaiSUS2img.Properties;

using System.Net.Http;
using System.Threading.Tasks;

namespace ChedPlugins
{
    public class SekaiSUS2img : IScorePlugin
    {
        public string DisplayName => "SekaiSUS2img";

        protected int BarIndexOffset => 0;

        private string Sus2ImgApiUrl => "https://sus2img.palettetool.com/";

        public void Run(IScorePluginArgs args)
        {
            Form form = new Form();
            form.Text = "SekaiSUS2img";
            form.Icon = Resources.icon;
            form.AutoSize = true;
            form.AutoSizeMode = AutoSizeMode.GrowAndShrink;

            WebView2 webView2 = new WebView2();
            webView2.Size = new Size(280, 800);
            try
            {
                async void InitializeAsync()
                {
                    await webView2.EnsureCoreWebView2Async(null);
                    string text = GetSusText(args);
                    string html = GetImg(text);
                    webView2.NavigateToString(html);
                }
                InitializeAsync();
            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message);
            }

            form.Controls.Add(webView2);
            form.Show();
        }

        private string GetImg(string text)
        {
            var client = new HttpClient();
            var content = new StringContent("chart=" + text, System.Text.Encoding.UTF8, @"application/x-www-form-urlencoded");
            Task<HttpResponseMessage> response =  client.PostAsync(Sus2ImgApiUrl, content);
            var responseText = response.Result.Content.ReadAsStringAsync().Result;
            return responseText;
        }

        private string GetSusText(IScorePluginArgs args)
        {
            var HasPaddingBar = false;
            var score = args.GetCurrentScore();
            var notes = score.Notes;
            var text = "";
            text += string.Format("This file was generated by Ched {0}.\n", System.Reflection.Assembly.GetEntryAssembly().GetName().Version.ToString());
            text += string.Format("#TITLE \"{0}\"\n", "");
            text += string.Format("#ARTIST \"{0}\"\n", "");
            text += string.Format("#DESIGNER \"{0}\"\n", "");
            text += string.Format("#DIFFICULTY {0}\n", "");
            text += string.Format("#PLAYLEVEL {0}\n", "");
            text += string.Format("#SONGID \"{0}\"\n", "");
            text += string.Format("#WAVE \"{0}\"\n", "");
            text += string.Format("#WAVEOFFSET {0}\n", "");
            text += string.Format("#JACKET \"{0}\"\n", "");
            text += "\n";
            text += string.Format("#REQUEST \"ticks_per_beat {0}\"", score.TicksPerBeat);
            text += "\n";

            int barTick = score.TicksPerBeat * 4;
            var barIndexCalculator = new BarIndexCalculator(barTick, score.Events.TimeSignatureChangeEvents, HasPaddingBar);

            foreach (var item in barIndexCalculator.TimeSignatures)
            {
                text += string.Format("#{0:000}02: {1}\n", item.StartBarIndex + (HasPaddingBar && item.StartBarIndex == 1 ? -1 : 0), 4f * item.TimeSignature.Numerator / item.TimeSignature.Denominator);
            }

            text += "\n";

            var bpmlist = score.Events.BpmChangeEvents
                    .GroupBy(p => p.Bpm)
                    .SelectMany((p, i) => p.Select(q => new { Index = i, Value = q, BarPosition = barIndexCalculator.GetBarPositionFromTick(q.Tick) }))
                    .ToList();

            if (bpmlist.Count >= 36 * 36) throw new ArgumentException("BPM定義数が上限を超えました。");

            var bpmIdentifiers = EnumerateIdentifiers(2).Skip(1).Take(bpmlist.Count).ToList();
            foreach (var item in bpmlist.GroupBy(p => p.Index).Select(p => p.First()))
            {
                text += string.Format("#BPM{0}: {1}\n", bpmIdentifiers[item.Index], item.Value.Bpm);
            }

            if (HasPaddingBar)
                text += string.Format("#{0:000}08: {1:x2}\n", 0, bpmIdentifiers[bpmlist.OrderBy(p => p.Value.Tick).First().Index]);

            foreach (var eventInBar in bpmlist.GroupBy(p => p.BarPosition.BarIndex))
            {
                var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(eventInBar.Key);
                int barLength = barTick * sig.Numerator / sig.Denominator;
                var dic = eventInBar.ToDictionary(p => p.BarPosition.TickOffset, p => p);
                int gcd = eventInBar.Select(p => p.BarPosition.TickOffset).Aggregate(barLength, (p, q) => GetGcd(p, q));
                text += string.Format("#{0:000}08: ", eventInBar.Key);
                for (int i = 0; i * gcd < barLength; i++)
                {
                    int tickOffset = i * gcd;
                    text += (dic.ContainsKey(tickOffset) ? bpmIdentifiers[dic[tickOffset].Index] : "00");
                }
                text += "\n";
            }

            text += "\n";
            var speeds = score.Events.HighSpeedChangeEvents.Select(p =>
            {
                var barPos = barIndexCalculator.GetBarPositionFromTick(p.Tick);
                return string.Format("{0}'{1}:{2}", HasPaddingBar && barPos.BarIndex == 1 && barPos.TickOffset == 0 ? 0 : barPos.BarIndex, barPos.TickOffset, p.SpeedRatio);
            });
            text += string.Format("#TIL00: \"{0}\"\n", string.Join(", ", speeds));
            text += "#HISPEED 00\n";
            text += "#MEASUREHS 00\n";

            text += "\n";

            var shortNotes = notes.Taps.Cast<TappableBase>().Select(p => new { Type = '1', Note = p })
                   .Concat(notes.ExTaps.Cast<TappableBase>().Select(p => new { Type = '2', Note = p }))
                   .Concat(notes.Flicks.Cast<TappableBase>().Select(p => new { Type = '3', Note = p }))
                   .Concat(notes.Damages.Cast<TappableBase>().Select(p => new { Type = '4', Note = p }))
                   .Select(p => new
                   {
                       BarPosition = barIndexCalculator.GetBarPositionFromTick(p.Note.Tick),
                       LaneIndex = p.Note.LaneIndex,
                       Width = p.Note.Width,
                       Type = p.Type
                   });

            foreach (var notesInBar in shortNotes.GroupBy(p => p.BarPosition.BarIndex))
            {
                foreach (var notesInLane in notesInBar.GroupBy(p => p.LaneIndex))
                {
                    var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(notesInBar.Key);
                    int barLength = barTick * sig.Numerator / sig.Denominator;

                    var offsetList = notesInLane.GroupBy(p => p.BarPosition.TickOffset).Select(p => p.ToList());
                    var separatedNotes = Enumerable.Range(0, offsetList.Max(p => p.Count)).Select(p => offsetList.Where(q => q.Count >= p + 1).Select(q => q[p]));

                    foreach (var dic in separatedNotes.Select(p => p.ToDictionary(q => q.BarPosition.TickOffset, q => q)))
                    {
                        int gcd = dic.Values.Select(p => p.BarPosition.TickOffset).Aggregate(barLength, (p, q) => GetGcd(p, q));
                        text += string.Format("#{0:000}1{1}:", notesInBar.Key, notesInLane.Key.ToString("x"));
                        for (int i = 0; i * gcd < barLength; i++)
                        {
                            int tickOffset = i * gcd;
                            text += (dic.ContainsKey(tickOffset) ? dic[tickOffset].Type + ToLaneWidthString(dic[tickOffset].Width) : "00");
                        }
                        text += "\n";
                    }
                }
            }

            var airs = notes.Airs.Select(p =>
            {
                string type = "";
                switch (p.HorizontalDirection)
                {
                    case HorizontalAirDirection.Center:
                        type = p.VerticalDirection == VerticalAirDirection.Up ? "1" : "2";
                        break;

                    case HorizontalAirDirection.Left:
                        type = p.VerticalDirection == VerticalAirDirection.Up ? "3" : "5";
                        break;

                    case HorizontalAirDirection.Right:
                        type = p.VerticalDirection == VerticalAirDirection.Up ? "4" : "6";
                        break;
                }

                return new
                {
                    BarPosition = barIndexCalculator.GetBarPositionFromTick(p.Tick),
                    LaneIndex = p.LaneIndex,
                    Type = type,
                    Width = p.Width
                };
            });

            foreach (var airsInBar in airs.GroupBy(p => p.BarPosition.BarIndex))
            {
                foreach (var airsInLane in airsInBar.GroupBy(p => p.LaneIndex))
                {
                    var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(airsInBar.Key);
                    int barLength = barTick * sig.Numerator / sig.Denominator;

                    var offsetList = airsInLane.GroupBy(p => p.BarPosition.TickOffset).Select(p => p.ToList());
                    var separatedNotes = Enumerable.Range(0, offsetList.Max(p => p.Count)).Select(p => offsetList.Where(q => q.Count >= p + 1).Select(q => q[p]));
                    foreach (var dic in separatedNotes.Select(p => p.ToDictionary(q => q.BarPosition.TickOffset, q => q)))
                    {
                        int gcd = dic.Values.Select(p => p.BarPosition.TickOffset).Aggregate(barLength, (p, q) => GetGcd(p, q));
                        text += string.Format("#{0:000}5{1}:", airsInBar.Key, airsInLane.Key.ToString("x"));
                        for (int i = 0; i * gcd < barLength; i++)
                        {
                            int tickOffset = i * gcd;
                            text += (dic.ContainsKey(tickOffset) ? dic[tickOffset].Type + ToLaneWidthString(dic[tickOffset].Width) : "00");
                        }
                        text += "\n";
                    }
                }
            }

            var identifier = new IdentifierAllocationManager();

            var holds = score.Notes.Holds
                .OrderBy(p => p.StartTick)
                .Select(p => new
                {
                    Identifier = identifier.Allocate(p.StartTick, p.Duration),
                    StartTick = p.StartTick,
                    EndTick = p.StartTick + p.Duration,
                    Width = p.Width,
                    LaneIndex = p.LaneIndex
                });

            foreach (var hold in holds)
            {
                var startBarPosition = barIndexCalculator.GetBarPositionFromTick(hold.StartTick);
                var endBarPosition = barIndexCalculator.GetBarPositionFromTick(hold.EndTick);
                if (startBarPosition.BarIndex == endBarPosition.BarIndex)
                {
                    var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(startBarPosition.BarIndex);
                    int barLength = barTick * sig.Numerator / sig.Denominator;
                    text += string.Format("#{0:000}2{1}{2}:", startBarPosition.BarIndex, hold.LaneIndex.ToString("x"), hold.Identifier);
                    int gcd = GetGcd(GetGcd(startBarPosition.TickOffset, endBarPosition.TickOffset), barLength);
                    for (int i = 0; i * gcd < barLength; i++)
                    {
                        int tickOffset = i * gcd;
                        if (startBarPosition.TickOffset == tickOffset) text += ("1" + ToLaneWidthString(hold.Width));
                        else if (endBarPosition.TickOffset == tickOffset) text += ("2" + ToLaneWidthString(hold.Width));
                        else text += "00";
                    }
                    text += "\n";
                }
                else
                {
                    var startSig = barIndexCalculator.GetTimeSignatureFromBarIndex(startBarPosition.BarIndex);
                    int startBarLength = barTick * startSig.Numerator / startSig.Denominator;
                    text += string.Format("#{0:000}2{1}{2}:", startBarPosition.BarIndex, hold.LaneIndex.ToString("x"), hold.Identifier);
                    int gcd = GetGcd(startBarPosition.TickOffset, startBarLength);
                    for (int i = 0; i * gcd < startBarLength; i++)
                    {
                        int tickOffset = i * gcd;
                        if (startBarPosition.TickOffset == tickOffset) text += ("1" + ToLaneWidthString(hold.Width));
                        else text += "00";
                    }
                    text += "\n";

                    var endSig = barIndexCalculator.GetTimeSignatureFromBarIndex(endBarPosition.BarIndex);
                    int endBarLength = barTick * endSig.Numerator / endSig.Denominator;
                    text += string.Format("#{0:000}2{1}{2}:", endBarPosition.BarIndex, hold.LaneIndex.ToString("x"), hold.Identifier);
                    gcd = GetGcd(endBarPosition.TickOffset, endBarLength);
                    for (int i = 0; i * gcd < endBarLength; i++)
                    {
                        int tickOffset = i * gcd;
                        if (endBarPosition.TickOffset == tickOffset) text += ("2" + ToLaneWidthString(hold.Width));
                        else text += "00";
                    }
                    text += "\n";
                }
            }
            identifier.Clear();

            var slides = notes.Slides
                .OrderBy(p => p.StartTick)
                .Select(p => new
                {
                    Identifier = identifier.Allocate(p.StartTick, p.GetDuration()),
                    Note = p
                });

            foreach (var slide in slides)
            {
                var start = new[] { new
                    {
                        TickOffset = 0,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(slide.Note.StartTick),
                        LaneIndex = slide.Note.StartLaneIndex,
                        Width = slide.Note.StartWidth,
                        Type = "1"
                    } };
                var steps = slide.Note.StepNotes.OrderBy(p => p.TickOffset).Select(p => new
                {
                    TickOffset = p.TickOffset,
                    BarPosition = barIndexCalculator.GetBarPositionFromTick(p.Tick),
                    LaneIndex = p.LaneIndex,
                    Width = p.Width,
                    Type = p.IsVisible ? "3" : "5"
                }).Take(slide.Note.StepNotes.Count - 1);
                var endNote = slide.Note.StepNotes.OrderBy(p => p.TickOffset).Last();
                var end = new[] { new
                    {
                        TickOffset = endNote.TickOffset,
                        BarPosition= barIndexCalculator.GetBarPositionFromTick(endNote.Tick),
                        LaneIndex = endNote.LaneIndex,
                        Width = endNote.Width,
                        Type = "2"
                    } };
                var slideNotes = start.Concat(steps).Concat(end);
                foreach (var notesInBar in slideNotes.GroupBy(p => p.BarPosition.BarIndex))
                {
                    foreach (var notesInLane in notesInBar.GroupBy(p => p.LaneIndex))
                    {
                        var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(notesInBar.Key);
                        int barLength = barTick * sig.Numerator / sig.Denominator;
                        int gcd = notesInLane.Select(p => p.BarPosition.TickOffset).Aggregate(barLength, (p, q) => GetGcd(p, q));
                        var dic = notesInLane.ToDictionary(p => p.BarPosition.TickOffset, p => p);
                        text += string.Format("#{0:000}3{1}{2}:", notesInBar.Key, notesInLane.Key.ToString("x"), slide.Identifier);
                        for (int i = 0; i * gcd < barLength; i++)
                        {
                            int tickOffset = i * gcd;
                            text += dic.ContainsKey(tickOffset) ? dic[tickOffset].Type + ToLaneWidthString(dic[tickOffset].Width) : "00";
                        }
                        text += "\n";
                    }
                }
            }

            identifier.Clear();

            var airActions = notes.AirActions
                .OrderBy(p => p.StartTick)
                .Select(p => new
                {
                    Identifier = identifier.Allocate(p.StartTick, p.GetDuration()),
                    Note = p
                });

            foreach (var airAction in airActions)
            {
                var start = new[] { new
                    {
                        TickOffset = 0,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(airAction.Note.StartTick),
                        Type = "1"
                    } };
                var actions = airAction.Note.ActionNotes.OrderBy(p => p.Offset).Select(p => new
                {
                    TickOffset = p.Offset,
                    BarPosition = barIndexCalculator.GetBarPositionFromTick(p.ParentNote.StartTick + p.Offset),
                    Type = "3"
                }).Take(airAction.Note.ActionNotes.Count - 1);
                var endNote = airAction.Note.ActionNotes.OrderBy(p => p.Offset).Last();
                var end = new[] { new
                    {
                        TickOffset = endNote.Offset,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(airAction.Note.StartTick + endNote.Offset),
                        Type = "2"
                    } };
                var actionNotes = start.Concat(actions).Concat(end);
                foreach (var airActionsInBar in actionNotes.GroupBy(p => p.BarPosition.BarIndex))
                {
                    var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(airActionsInBar.Key);
                    int barLength = barTick * sig.Numerator / sig.Denominator;
                    text += string.Format("#{0:000}4{1}{2}:", airActionsInBar.Key, airAction.Note.ParentNote.LaneIndex.ToString("x"), airAction.Identifier);
                    int gcd = airActionsInBar.Select(p => p.BarPosition.TickOffset).Aggregate(barLength, (p, q) => GetGcd(p, q));
                    var dic = airActionsInBar.ToDictionary(p => p.BarPosition.TickOffset, p => p);
                    for (int i = 0; i * gcd < barLength; i++)
                    {
                        int tickOffset = i * gcd;
                        if (dic.ContainsKey(tickOffset)) text += string.Format("{0}{1}", dic[tickOffset].Type, ToLaneWidthString(airAction.Note.ParentNote.Width));
                        else text += "00";
                    }
                    text += "\n";
                }
            }
            return text;
        }

        private int GetGcd(int a, int b)
        {
            if (a < b) return GetGcd(b, a);
            if (b == 0) return a;
            return GetGcd(b, a % b);
        }

        private string ToLaneWidthString(int width)
        {
            return width == 16 ? "g" : width.ToString("x");
        }

        private static IEnumerable<string> EnumerateIdentifiers(int digits)
        {
            var num = Enumerable.Range(0, 10).Select(p => (char)('0' + p));
            var alpha = Enumerable.Range(0, 26).Select(p => (char)('A' + p));
            var seq = num.Concat(alpha).Select(p => p.ToString()).ToList();

            return EnumerateIdentifiers(digits, seq);
        }

        private static IEnumerable<string> EnumerateIdentifiers(int digits, List<string> seq)
        {
            if (digits < 1) throw new ArgumentOutOfRangeException("digits");
            if (digits == 1) return seq;
            return EnumerateIdentifiers(digits - 1, seq).SelectMany(p => seq.Select(q => p + q));
        }

        private class IdentifierAllocationManager
        {
            private int lastStartTick;
            private Stack<char> IdentifierStack;
            private ConcurrentPriorityQueue<Tuple<int, char>, int> UsedIdentifiers;

            public IdentifierAllocationManager()
            {
                Clear();
            }

            public void Clear()
            {
                lastStartTick = 0;
                IdentifierStack = new Stack<char>(EnumerateIdentifiers(1).Select(p => p.Single()).Reverse());
                UsedIdentifiers = new ConcurrentPriorityQueue<Tuple<int, char>, int>();
            }

            public char Allocate(int startTick, int duration)
            {
                if (startTick < lastStartTick) throw new InvalidOperationException("startTick must not be less than last called value.");
                while (UsedIdentifiers.Count > 0 && UsedIdentifiers.Peek().Item1 < startTick)
                {
                    IdentifierStack.Push(UsedIdentifiers.Dequeue().Item2);
                }
                char c = IdentifierStack.Pop();
                int endTick = startTick + duration;
                UsedIdentifiers.Enqueue(Tuple.Create(endTick, c), -endTick);
                lastStartTick = startTick;
                return c;
            }
        }

        private class BarIndexCalculator
        {
            private bool hasPaddingBar;
            private int barTick;
            private SortedDictionary<int, TimeSignatureItem> timeSignatures;

            /// <summary>
            /// 時間順にソートされた有効な拍子変更イベントのコレクションを取得します。
            /// </summary>
            public IEnumerable<TimeSignatureItem> TimeSignatures
            {
                get { return timeSignatures.Select(p => p.Value).Reverse(); }
            }

            public BarIndexCalculator(int barTick, IEnumerable<TimeSignatureChangeEvent> events, bool hasPaddingBar)
            {
                this.hasPaddingBar = hasPaddingBar;
                this.barTick = barTick;
                var ordered = events.OrderBy(p => p.Tick).ToList();
                var dic = new SortedDictionary<int, TimeSignatureItem>();
                int pos = 0;
                int barIndex = hasPaddingBar ? 1 : 0;
                for (int i = 0; i < ordered.Count; i++)
                {
                    var item = new TimeSignatureItem()
                    {
                        StartTick = pos,
                        StartBarIndex = barIndex,
                        TimeSignature = ordered[i]
                    };

                    // 時間逆順で追加
                    if (dic.ContainsKey(-pos)) dic[-pos] = item;
                    else dic.Add(-pos, item);

                    if (i < ordered.Count - 1)
                    {
                        int barLength = barTick * ordered[i].Numerator / ordered[i].Denominator;
                        int duration = ordered[i + 1].Tick - pos;
                        pos += duration / barLength * barLength;
                        barIndex += duration / barLength;
                    }
                }

                timeSignatures = dic;
            }

            public BarPosition GetBarPositionFromTick(int tick)
            {
                foreach (var item in timeSignatures)
                {
                    if (tick < item.Value.StartTick) continue;
                    var sig = item.Value.TimeSignature;
                    int barLength = barTick * sig.Numerator / sig.Denominator;
                    int tickOffset = tick - item.Value.StartTick;
                    int barOffset = tickOffset / barLength;
                    return new BarPosition()
                    {
                        BarIndex = item.Value.StartBarIndex + barOffset,
                        TickOffset = tickOffset - barOffset * barLength,
                        TimeSignature = item.Value.TimeSignature
                    };
                }

                throw new InvalidOperationException();
            }

            public TimeSignatureChangeEvent GetTimeSignatureFromBarIndex(int barIndex)
            {
                foreach (var item in timeSignatures)
                {
                    if (barIndex < item.Value.StartBarIndex) continue;
                    return item.Value.TimeSignature;
                }

                throw new InvalidOperationException();
            }

            public struct BarPosition
            {
                public int BarIndex { get; set; }
                public int TickOffset { get; set; }
                public TimeSignatureChangeEvent TimeSignature { get; set; }
            }

            public class TimeSignatureItem
            {
                public int StartTick { get; set; }
                public int StartBarIndex { get; set; }
                public TimeSignatureChangeEvent TimeSignature { get; set; }
            }
        }
    }
}

